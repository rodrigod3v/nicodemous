using SharpHook;
using SharpHook.Native;
using System.Text.Json;

namespace Nicodemous.Backend.Services;

public enum ScreenEdge
{
    None,
    Left,
    Right,
    Top,
    Bottom
}

public class InputService
{
    private readonly SimpleGlobalHook _hook;
    private readonly IEventSimulator _simulator;
    private readonly Action<byte[]> _onData;
    private bool _isRemoteMode = false;
    private short _screenWidth = 1920;
    private short _screenHeight = 1080;
    private ScreenEdge _activeEdge = ScreenEdge.Right; // Default: Right edge crosses to remote
    private bool _isInputLocked = true; // Default: Lock mouse to edge when in remote mode
    private DateTime _lastReturnTime = DateTime.MinValue;
    private const int CooldownMs = 1000;

    private double _virtualX;
    private double _virtualY;
    private bool _isSuppressingEvents = false;
    private double _accumulatedReturnDelta = 0;

    public event Action<ScreenEdge>? OnEdgeHit;
    public event Action? OnReturn;

    public void SetActiveEdge(string edge)
    {
        _activeEdge = Enum.TryParse<ScreenEdge>(edge, true, out var result) ? result : ScreenEdge.Right;
        Console.WriteLine($"InputService: Active Edge set to {_activeEdge}");
    }

    public void SetInputLock(bool locked)
    {
        _isInputLocked = locked;
        Console.WriteLine($"InputService: Input Lock set to {locked}");
    }

    public InputService(Action<byte[]> onData)
    {
        _hook = new SimpleGlobalHook();
        _simulator = new EventSimulator();
        _onData = onData;

        _hook.MouseMoved += OnMouseMoved;
        _hook.MousePressed += OnMousePressed;
        _hook.MouseReleased += OnMouseReleased;
        _hook.KeyPressed += OnKeyPressed;
        _hook.KeyReleased += OnKeyReleased;
    }

    public void SetScreenSize(short width, short height)
    {
        _screenWidth = width;
        _screenHeight = height;
    }

    public void SetRemoteMode(bool enabled)
    {
        _isRemoteMode = enabled;
        if (enabled)
        {
            // Invert logic: If we hit PC's RIGHT edge, start at Mac's LEFT edge (+ buffer)
            // If we hit PC's LEFT edge, start at Mac's RIGHT edge (- buffer)
            const int entryBuffer = 50;
            if (_activeEdge == ScreenEdge.Right)
            {
                _virtualX = entryBuffer;
            }
            else
            {
                _virtualX = _screenWidth - entryBuffer;
            }

            _virtualY = _screenHeight / 2.0;
            _accumulatedReturnDelta = 0;
            Console.WriteLine($"[INPUT] Remote Mode Enabled. Entering at Virtual Pos: {_virtualX},{_virtualY}");
        }
    }

    public void Start()
    {
        Task.Run(() => _hook.Run());
    }

    public void Stop()
    {
        _hook.Dispose();
    }

    private void OnMouseMoved(object? sender, MouseHookEventArgs e)
    {
        if (_isSuppressingEvents) return; // Skip events generated by our own simulator

        if (_isRemoteMode)
        {
            if (_screenWidth == 0 || _screenHeight == 0) return;

            // Suppress the event locally
            e.SuppressEvent = true;

            HandleMouseLock(e.Data.X, e.Data.Y);

            // Normalize virtual position to 0-65535 range
            ushort normX = (ushort)(Math.Clamp(_virtualX / _screenWidth, 0, 1) * 65535);
            ushort normY = (ushort)(Math.Clamp(_virtualY / _screenHeight, 0, 1) * 65535);

            // Send normalized coordinates to remote
            _onData(PacketSerializer.SerializeMouseMove(normX, normY));
        }
        else
        {
            // Check for cooldown to avoid immediate re-entry when pulling back
            if ((DateTime.Now - _lastReturnTime).TotalMilliseconds < CooldownMs) return;

            // Check for edge hit to trigger remote mode
            if (e.Data.X >= _screenWidth - 1 && _activeEdge == ScreenEdge.Right)
            {
                OnEdgeHit?.Invoke(ScreenEdge.Right);
            }
            else if (e.Data.X <= 0 && _activeEdge == ScreenEdge.Left)
            {
                OnEdgeHit?.Invoke(ScreenEdge.Left);
            }
        }
    }

    private void HandleMouseLock(short x, short y)
    {
        if (!_isInputLocked) return;

        // Sticky point: the pixel at the edge and center-height
        short stickyX = (_activeEdge == ScreenEdge.Right) ? (short)(_screenWidth - 1) : (short)0;
        short stickyY = (short)(_screenHeight / 2);

        // Calculate deltas from the sticky point
        int dx = x - stickyX;
        int dy = y - stickyY;

        // If no movement relative to sticky point, nothing to do
        if (dx == 0 && dy == 0) return;

        // Update virtual position
        _virtualX += dx;
        _virtualY += dy;

        // Clamp virtual position to reasonable bounds (can go slightly off-screen if desired, 
        // but here we clamp to 0..Width/Height for simplicity)
        _virtualX = Math.Clamp(_virtualX, 0, _screenWidth);
        _virtualY = Math.Clamp(_virtualY, 0, _screenHeight);

        // Return detection: track how much the user is pulling BACK from the edge
        // Only start accumulating return delta IF virtual position is already at the edge 
        // that faces the primary computer. This creates a "sticky wall" effect.
        bool isAtReturnEdge = (_activeEdge == ScreenEdge.Right && _virtualX <= 0) || 
                              (_activeEdge == ScreenEdge.Left && _virtualX >= _screenWidth);

        if (isAtReturnEdge)
        {
            if (_activeEdge == ScreenEdge.Right && dx < 0)
            {
                _accumulatedReturnDelta += Math.Abs(dx);
            }
            else if (_activeEdge == ScreenEdge.Left && dx > 0)
            {
                _accumulatedReturnDelta += Math.Abs(dx);
            }
            else if (dx != 0)
            {
                // Reset accumulated return if moving AWAY from the return edge
                _accumulatedReturnDelta = 0;
            }
        }
        else
        {
            _accumulatedReturnDelta = 0;
        }

        const int returnThreshold = 400; 
        if (_accumulatedReturnDelta > returnThreshold)
        {
            Console.WriteLine($"[INPUT] Return detected! Accumulated Delta: {_accumulatedReturnDelta}");
            _lastReturnTime = DateTime.Now;
            OnReturn?.Invoke();
            return;
        }

        // Force the physical cursor back to the sticky point to prevent local interaction
        _isSuppressingEvents = true;
        _simulator.SimulateMouseMovement(stickyX, stickyY);
        _isSuppressingEvents = false;
    }

    private void OnMousePressed(object? sender, MouseHookEventArgs e)
    {
        if (_isRemoteMode)
        {
            e.SuppressEvent = true;
            _onData(PacketSerializer.SerializeMouseDown(e.Data.Button.ToString()));
        }
    }

    private void OnMouseReleased(object? sender, MouseHookEventArgs e)
    {
        if (_isRemoteMode)
        {
            e.SuppressEvent = true;
            _onData(PacketSerializer.SerializeMouseUp(e.Data.Button.ToString()));
        }
    }

    private void OnKeyPressed(object? sender, KeyboardHookEventArgs e)
    {
        if (_isRemoteMode)
        {
            e.SuppressEvent = true;
            _onData(PacketSerializer.SerializeKeyPress(e.Data.KeyCode.ToString()));
        }
    }

    private void OnKeyReleased(object? sender, KeyboardHookEventArgs e)
    {
        if (_isRemoteMode)
        {
            e.SuppressEvent = true;
        }
    }
}
